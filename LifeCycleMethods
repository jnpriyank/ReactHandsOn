

// timer practical
class Timer extends React.Component
{
	constructor(props){
    	super(props);
        console.log(this);
        this.state = { timeElapsed: 0};
        console.log(this.state);
        console.log(this.props);
        /* will not be available
        console.log('nextProps');
        console.log(nextProps);
        console.log('nextState');        
        console.log(nextState);
        */
    }
    
	tick(){
    	this.setState({timeElapsed: this.state.timeElapsed+1});
    }

	// component will not update, initial render and forupdate works.
    //shouldComponentUpdate(nextProps,nextState){    return false;    }
	shouldComponentUpdate(nextProps,nextState){    
    	console.log('nextProps');
        console.log(nextProps);
        console.log('nextState');        
        console.log(nextState);
    // here you can compare previous and next props and state values and
    // decide what should be done.
    return false;
    }
    //componentWillMount(){}
    componentDidMount(){
    //this.interval = setInterval(this.tick,1000);	// not working
    //this.interval = setInterval(()=>{this.tick();},1000);
    this.interval = setInterval(()=>this.tick(),1000);
    }
    
    componentWillUnmount(){
    	clearInterval(this.interval);
    }
    
    render(){
    	return <div>Time Elapsed: {this.state.timeElapsed}</div>;
    }
}

ReactDOM.render(<Timer name='prop'/>,mountNode);

// using nextProps and nextState
class Timer extends React.Component
{
	constructor(props){
    	super(props);
        //console.log(this);
        this.state = { timeElapsed: 0};
        //console.log(this.state);
        //console.log(this.props);
        /* will not be available
        console.log('nextProps');
        console.log(nextProps);
        console.log('nextState');        
        console.log(nextState);
        */
    }
    
	tick(){
    	this.setState({timeElapsed: this.state.timeElapsed+1});
    }

	// component will not update, initial render and forupdate works.
    //shouldComponentUpdate(nextProps,nextState){    return false;    }
	shouldComponentUpdate(nextProps,nextState){    
    	/*	working
        console.log('nextProps');
        console.log(nextProps);
        console.log('nextState');        
        console.log(nextState);
        */
    // here you can compare previous and next props and state values and
    // decide what should be done.
    return false;
    }
    //componentWillMount(){}
    componentDidMount(nextProps,nextState){
    	//this.interval = setInterval(this.tick,1000);	// not working
    	//this.interval = setInterval(()=>{this.tick();},1000);
    	this.interval = setInterval(()=>this.tick(),1000);
   /* not working
        console.log('nextProps');
        console.log(nextProps);
        console.log('nextState');        
        console.log(nextState);
        */
     }
     
     componentWillReceiveProps(){
     /* didn't understood it.
   console.log('nextProps');
         console.log(nextProps);
        console.log('nextState');        
        console.log(nextState);
      */
     }
    
    componentWillUnmount(){
    	clearInterval(this.interval);
    }
    
    render(){
    	return <div>Time Elapsed: {this.state.timeElapsed}</div>;
    }
}

ReactDOM.render(<Timer name='prop'/>,mountNode);
